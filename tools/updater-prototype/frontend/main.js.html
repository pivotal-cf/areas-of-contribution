<script>

// step 1: user clicked Update button
function update() {
  var userIntent = getUserInputs();
  
  if (!isEditLink(userIntent.formUrl)) {
    return
  }
  setFormEnabled(false);
  setStatusMessage({progress: 'reading form and sheet... this may take several minutes'});
  
  
  const contentPromises = {
    "migrateFromAreas": userIntent.migrateFrom.areasPromise = github.fetchYaml(userIntent.migrateFrom.gitRef, github.files.areas),
    "migrateFromSkills": userIntent.migrateFrom.skillsPromise = github.fetchYaml(userIntent.migrateFrom.gitRef, github.files.skills),
    "migrateToAreas": userIntent.migrateTo.areasPromise = github.fetchYaml(userIntent.migrateTo.gitRef, github.files.areas),
    "migrateToSkills": userIntent.migrateTo.skillsPromise = github.fetchYaml(userIntent.migrateTo.gitRef, github.files.skills),
  };
  Object.entries(contentPromises).forEach(([id, promise]) => {
    promise.then(content => reportYaml(id, content));
  });

  // async launch step 2: getCurrentState on server
  google.script.run
    .withFailureHandler(onFailure)
    .withSuccessHandler(gotCurrentState)
    .withUserObject(userIntent)
    .getCurrentState(userIntent.formUrl);
}

// step 2 is in backend/main.gs, getCurrentState

// step 3
function gotCurrentState(currentState, userIntent) {
    setStatusMessage({progress: "validating current form and sheet" })
    reportYaml("origResponseSheetCols", currentState.responsesSheet.columnHeaders);
    reportYaml("origForm", currentState.form);
    
    migrationSpecPromise(userIntent).then(migrationPlan => {
      const missingColumns = detectResponseSheetMissingColumns(currentState, migrationPlan.migrateFrom.skills);
      if (missingColumns.size > 0) {
        onFailure({message: "Current sheet doesn't match expected current version: form responses sheet is missing expected column " + Array.from(missingColumns).toString() });
        return
      }
      
      const plannedFormEdits = planFormEdits(currentState.form, migrationPlan);
      reportYaml("planFormEdits", plannedFormEdits);
    
      setStatusMessage({success: "ok for now" })
      
      // async launch step 4: migrateFormAndSheet
      setStatusMessage({progress: "updating form" })
      google.script.run
        .withFailureHandler(onFailure)
        .withSuccessHandler(updatedForm)
        .withUserObject(userIntent)
        .migrateFormAndSheet({
           formUrl: userIntent.formUrl,
           migrationPlan: migrationPlan,
           edits: plannedFormEdits,
         });
       
    });
}

// step 4 is in backend/main.gs, migrateFormAndSheet

// step 5
function updatedForm(result) {
  onSuccess("updated form: " + JSON.stringify(result));
}


function migrationSpecPromise(userIntent) {
    return Promise.all([
       userIntent.migrateFrom.areasPromise,
       userIntent.migrateFrom.skillsPromise,
       userIntent.migrateTo.areasPromise,
       userIntent.migrateTo.skillsPromise,
    ]).then(([mfA,mfS,mtA,mtS]) => {
      return {
        migrateFrom: { areas: mfA.areas, skills: mfS.skills, gitRef: userIntent.migrateFrom.gitRef },
        migrateTo: { areas: mtA.areas, skills: mtS.skills, gitRef: userIntent.migrateTo.gitRef },
      }
    });
}

function detectPage(pageBreakTitle, areas) {
  var i;
  for (i = 0; i < areas.length; i++) {
     const areaTitle = getFormSectionTitle(areas[i]);
     if (pageBreakTitle === areaTitle) {
       return { area: areas[i], basic: true };
     } else if (pageBreakTitle === "Advanced " + areaTitle) {
       return { area: areas[i], basic: false };
     }
  }
  return null;
}

function buildCheckboxRows(page, skills) {
  return skills
    .filter(s => s.area === page.area.id)
    .filter(s => (isBasic(s) === page.basic))
    .map(s => s.description);
}


function planFormEdits(currentForm, migrationPlan) {
  var edits = [];
  
  var currentPage;
  currentForm.items.forEach(item => {
    if (item.type === "PAGE_BREAK") {
      currentPage = detectPage(item.title, migrationPlan.migrateFrom.areas);
      return
    }
    if (item.type === "CHECKBOX_GRID") {
      const expectedRows = buildCheckboxRows(currentPage, migrationPlan.migrateTo.skills);
      if (expectedRows.length < 1) {
        throw "error: no expected rows for " + JSON.stringify(currentPage);
      }
      if (!arraysAreEqual(item.rows, expectedRows)) {
        edits.push({ id: item.id, newRows: expectedRows});
      }
      return
    }
  });
  // for now we only support editing skill definitions
  return edits;
}

function arraysAreEqual(a, b) {
  if (a.length != b.length) {
    return false
  }
  return a.every((v, i) => v === b[i]);
}

function detectResponseSheetMissingColumns(currentState, expectedSkills) {
  const actualColumns = new Set(currentState.responsesSheet.columnHeaders);
  const expectedColumns = new Set(expectedSkills.map(s => s.description).map(formatSkillForSheet));
  var missingColumns = new Set();
  expectedColumns.forEach(s => {
      if (!actualColumns.has(s)) {
          missingColumns.add(s);
        }
      });
  return missingColumns;
}


function isBasic(s) { return s.level == "p1" || s.level == "p2" }

function rowToSkill(row) {
  return { level: row[1].toLowerCase(), description: row[0].substring(2,row[0].length-1) };
}

function formatSkillForSheet(skillDescription) {
  return " [" + skillDescription + "]";
}

function getSheetTitle(a) {
  return a.sheet ? a.sheet.title : a.title;
}

function getFormSectionTitle(a) {
  return a.form ? a.form.title : a.title;
}

</script>